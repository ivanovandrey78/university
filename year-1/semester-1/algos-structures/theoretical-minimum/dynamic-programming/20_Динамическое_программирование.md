## 20. Динамическое программирование:  

### Общая идея динамического программирования

**Динамическое программирование (DP)** — это метод решения задач,  
в которых решение можно представить как комбинацию **решений подзадач**,  
и каждая подзадача **используется многократно**.

Идея:

- Разбить задачу на подзадачи.
    
- Решать их один раз.
    
- Сохранять результаты (мемоизация / табуляция).
    

DP обычно применимо, если выполняются два свойства:

1. **Оптимальная подструктура** — оптимальное решение составляется из оптимальных подрешений.
    
2. **Пересекающиеся подзадачи** — одни и те же подпроблемы встречаются многократно.

### кузнечик

#### Условие

Кузнечик сидит на клетке `1` и может прыгать вперёд на 1 или 2 клетки.  
Нужно посчитать, **сколькими способами** он может добраться до клетки `n`.

### Рекуррентное соотношение

```
dp[i] = dp[i−1] + dp[i−2]
```

где

- `dp[i]` — количество способов добраться до клетки `i`.

#### Реализация 

```cpp
int grasshopper(int n) {
    int dp[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i <= n; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
    return dp[n];
}
```

модификация (теперь без использования массива)
```cpp
int grasshopper(int n) {
    if (n == 1) return 1;
    if (n == 2) return 1;

    int prev2 = 1; // dp[i-2]
    int prev1 = 2; // dp[i-1]
    int curr;

    for (int i = 3; i <= n; i++) {
        curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return curr;
}
```

#### Асимптотика

| Время  | Память                              |
| ------ | ----------------------------------- |
| `O(n)` | `O(n)` (или `O(1)` при оптимизации) |

### рюкзак

#### Постановка задачи

Есть `n` предметов, каждый с:

- весом `w[i]`,
    
- ценностью (стоимостью) `c[i]`.
    

Дан рюкзак вместимости `W`.  
Нужно выбрать набор предметов так, чтобы:

- **суммарный вес ≤ W**,
    
- **суммарная ценность** — **максимальна**.  
    При этом **предмет можно взять только один раз**

#### Рекуррентная формула

Пусть `dp[i][j]` — **максимальная ценность**,  
которую можно получить, рассматривая **первые `i` предметов** и рюкзак вместимости `j`.

```
dp[i][j] = dp[i − 1][j] // если w[i] > j (не помещается)
dp[i][j] = max(dp[i − 1][j], dp[i − 1][j − w[i]] + c[i]) // если w[i] <= i
```

#### Пример

Пусть:

| i   | Вес | Цена |
| --- | --- | ---- |
| 1   | 2   | 3    |
| 2   | 3   | 4    |
| 3   | 4   | 5    |

`W = 5`

#### Пошаговое построение `dp` :

| i / W | 0   | 1   | 2   | 3   | 4   | 5   |
| ----- | --- | --- | --- | --- | --- | --- |
| 0     | 0   | 0   | 0   | 0   | 0   | 0   |
| 1     | 0   | 0   | 3   | 3   | 3   | 3   |
| 2     | 0   | 0   | 3   | 4   | 4   | 7   |
| 3     | 0   | 0   | 3   | 4   | 5   | 7   |

##### Как заполняем таблицу

Мы будем идти **построчно (по предметам)** и **покомпонентно (по весу)**.  
Формула:

```cpp
if (w[i] <= j)
    dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i]] + c[i])
else
    dp[i][j] = dp[i-1][j];
```

Расшифровка:

- `dp[i-1][j]` — не берём предмет `i` (ценность такая же, как без него);
    
- `dp[i-1][j - w[i]] + c[i]` — берём предмет `i`:
    
    - убираем из рюкзака место под его вес `w[i]`;
        
    - добавляем его ценность `c[i]`.
        

Берём максимум из этих двух вариантов.

#### Реализация

dp как двумерный массив:
```cpp
int knapsack(int n, int W, int* w, int* c) {
    int dp[n + 1][W + 1] = {0};

    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= W; j++) {
            if (w[i - 1] <= j)
                dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + c[i - 1]);
            else
                dp[i][j] = dp[i - 1][j];
        }
    }
    return dp[n][W];
}
```

dp как одномерный массив:
```cpp
int knapsack(int n, int W, int* w, int* c) {
    int dp[W + 1] = {0};
    for (int i = 0; i < n; i++) {
        for (int j = W; j >= w[i]; j--) {
            dp[j] = std::max(dp[j], dp[j - w[i]] + c[i]);
        }
    }
    return dp[W];
}
```

#### Почему работает 1D реализация

В классическом (2D) варианте dp[i][j] хранит максимум для первых i предметов и вместимости j.
Когда мы переходим к предмету i+1, мы используем только предыдущую строку dp[i−1][...].

Чтобы не хранить всю таблицу, можно «свернуть» её в один массив dp[j],
где dp[j] всегда будет обозначать текущее максимальное значение для вместимости j.

Важное условие — **порядок обхода**:

Чтобы не «перезаписать» значения, которые нам ещё понадобятся,
внутренний цикл по j нужно выполнять в обратном порядке — от W к w[i].

#### Асимптотика 

|Параметр|Асимптотика|
|---|---|
|Время|`O(n * W)`|
|Память (2D)`|`O(n * W)`|
|Память (1D)`|`O(W)`|


#### Восстановление ответа

После того как таблица `dp[i][j]` заполнена, значение `dp[n][W]` показывает **максимальную ценность**,  
но **какие предметы взяты**, нужно восстановить отдельно.

##### Алгоритм восстановления

1. Начинаем с нижнего правого угла: `i = n`, `j = W`.
    
2. Пока `i > 0` и `j > 0`:
    
    - Если `dp[i][j] == dp[i - 1][j]`,  
        → предмет `i` **не был взят**, идём к `i = i - 1`.
        
    - Иначе  
        → предмет `i` **взят**,  
        запоминаем его и переходим к:
        
        `j = j - w[i - 1]`
        `i = i - 1`
        
3. Получаем список всех взятых предметов (его можно развернуть для порядка).
    

##### Пример восстановления

| i / W | 0   | 1   | 2   | 3   | 4   | 5   |
| ----- | --- | --- | --- | --- | --- | --- |
| 0     | 0   | 0   | 0   | 0   | 0   | 0   |
| 1     | 0   | 0   | 3   | 3   | 3   | 3   |
| 2     | 0   | 0   | 3   | 4   | 4   | 7   |
| 3     | 0   | 0   | 3   | 4   | 5   | 7   |

`dp[3][5] = 7`

- `dp[3][5] == dp[2][5]` → предмет 3 не взят
    
- `dp[2][5] != dp[1][5]` → предмет 2 взят → `j = 5 - 3 = 2`
    
- `dp[1][2] != dp[0][2]` → предмет 1 взят  
    → ответ: {1, 2}, суммарная ценность = 7.
    

##### Код восстановления

```cpp
void restoreItems(int n, int W, int* w, int* c, int dp[][101]) {
    int j = W;
    std::vector<int> items;

    for (int i = n; i > 0; i--) {
        if (dp[i][j] != dp[i - 1][j]) {
            items.push_back(i);
            j -= w[i - 1];
        }
    }

    std::reverse(items.begin(), items.end());
    std::cout << "Взятые предметы: ";
    for (int x : items) std::cout << x << " ";
}

```

---

##### Асимптотика

| Параметр    | Асимптотика |
| ----------- | ----------- |
| Время       | `O(n * W)`  |
| Память (2D) | `O(n * W)`  |
| Память (1D) | `O(W)`      |


### Наибольшая возрастающая подпоследовательность (Longest Increasing Subsequence, LIS)

#### Постановка задачи

Дана последовательность чисел: `a₁, a₂, ..., aₙ`

Нужно найти **длину самой длинной строго возрастающей подпоследовательности**,  
т.е. выбрать элементы с возрастающими индексами и значениями:

`a[i₁] < a[i₂] < ... < a[iₖ]`  так, чтобы `k` — было **максимально возможным**.

#### Пример

Пусть дана последовательность:

`a = [3, 1, 5, 2, 6, 4, 9]`

Одна из самых длинных возрастающих подпоследовательностей:

`[1, 2, 4, 9]`

#### Идея динамического программирования

Для каждого элемента `a[i]` будем хранить:

> `dp[i]` — длина наибольшей возрастающей подпоследовательности,  
> **заканчивающейся именно на элементе `a[i]`**.

#### Формула перехода:

Для всех `j < i`, если `a[j] < a[i]`, то  
элемент `a[i]` можно поставить **после** `a[j]` в возрастающую подпоследовательность.

`dp[i] = max(dp[j]) + 1   для всех j < i, где a[j] < a[i]`

#### Реализация

```cpp
int LIS(int a[], int n) {
    int dp[n];
    for (int i = 0; i < n; i++) dp[i] = 1; // каждая сама по себе

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (a[j] < a[i]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }

    int ans = 0;
    for (int i = 0; i < n; i++)
        ans = max(ans, dp[i]);
    return ans;
}
```

#### Асимптотика

- Временная — `O(n²)`
- Память — `O(n)`

возможна оптимизация за O(nlogn) через бинарный поиск

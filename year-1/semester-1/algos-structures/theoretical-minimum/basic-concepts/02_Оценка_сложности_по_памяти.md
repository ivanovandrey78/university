## 2. Оценка сложности алгоритма по памяти  

**Пространственная сложность алгоритма** — это функция, показывающая, **сколько памяти** требуется алгоритму в зависимости от размера входных данных `n`.

> Цель: определить, как быстро растёт потребление памяти при увеличении размера входа.

---

### Компоненты, влияющие на память

|Компонент|Пример|Тип памяти|
|---|---|---|
|**Входные данные**|массив `a[n]`, граф, дерево|постоянная часть|
|**Выходные данные**|результирующий массив, структура|постоянная часть|
|**Вспомогательные переменные**|счётчики, временные буферы|дополнительная память|
|**Память под рекурсию**|стек вызовов, локальные переменные|дополнительная память|
|**Динамические структуры**|векторы, списки, хэш-таблицы|дополнительная память|

---

### Что учитывается при оценке

- локальные и глобальные переменные;
    
- динамические выделения памяти (`new`, `malloc` и т. п.);
    
- стек вызовов при рекурсии;
    
- временные массивы и буферы.
    

> Обычно **входные и выходные данные** не включаются в оценку — интересует именно **дополнительная память**, необходимая алгоритму для вычислений.

---

### Типы пространственной сложности

|Тип|Обозначение|Пример использования|
|---|---|---|
|**O(1)**|Константная|Поиск минимума в массиве|
|**O(log n)**|Логарифмическая|Глубина рекурсии при бинарном поиске|
|**O(n)**|Линейная|Временный массив для сортировки, список|
|**O(n²)**|Квадратичная|Таблицы динамического программирования|

---

### Стек вызовов и рекурсия

Каждый рекурсивный вызов сохраняет в **стеке**:

- адрес возврата,
    
- значения параметров функции,
    
- локальные переменные.
    

Если глубина рекурсии равна `k`, то память под стек вызовов — `O(k)`.

> Поэтому рекурсивные алгоритмы часто заменяют **итеративными**, чтобы снизить использование памяти.

---

### Пример — Merge Sort

- **Стек рекурсии:** глубина рекурсии `O(log n)`
    
- **Временные массивы при слиянии:** `O(n)`
    
- **Общая пространственная сложность:** `O(n)`, так как `n >> log n`
## 1. Оценка сложности алгоритма по времени

**Временная сложность алгоритма** — это функция, которая показывает, сколько операций выполняет алгоритм в зависимости от размера входных данных `n`.

> **Цель оценки** — понять, как изменяется количество операций (или время работы) алгоритма с увеличением объёма данных.

---

### Виды асимптотических оценок

|Вид оценки|Обозначение|Описание|
|---|---|---|
|**Оценка сверху**|`O(f(n))`|Время работы **не превышает** `f(n)` (в худшем случае).|
|**Оценка снизу**|`Ω(f(n))`|Время работы **не меньше**, чем `f(n)` (в лучшем случае).|
|**Точная оценка**|`Θ(f(n))`|Время работы точно равно `f(n)` — как сверху, так и снизу.|

---

### Формулировки

- **Большое O (верхняя граница)**  
    `T(n) = O(f(n))`, если существуют константы `c > 0` и `n₀`, такие что  
    `T(n) ≤ c * f(n)` для всех `n ≥ n₀`.
    
- **Большое Ω (нижняя граница)**  
    `T(n) = Ω(f(n))`, если существуют константы `c > 0` и `n₀`, такие что  
    `T(n) ≥ c * f(n)` для всех `n ≥ n₀`.
    
- **Точная асимптотика (Θ-оценка)**  
    `T(n) = Θ(f(n))`, если `T(n)` одновременно `O(f(n))` и `Ω(f(n))`.
    

---

### Связь случаев и оценок

Временная сложность алгоритма анализируется в зависимости от **входных данных**, которые могут привести к различным временам выполнения. Эти варианты называются **случаями**.

|Сценарий|Обозначение|Пример|
|---|---|---|
|**Лучший случай**|`Ω(f(n))`|Элемент найден сразу — минимальное время.|
|**Худший случай**|`O(f(n))`|Элемент отсутствует — требуется полный обход.|
|**Средний случай**|`Θ(f(n))`|Ожидаемое время при случайных входных данных.|

---

### Почему не делают по три оценки для каждого случая

На первый взгляд, кажется логичным оценивать **каждый случай** (лучший, средний, худший) тремя границами — `O`, `Ω` и `Θ`.  
Однако на практике это **бессмысленно**, и вот почему:

1. **Случай** — это характеристика **входных данных**.  
    Например, для сортировки вставками:
    
    - лучший случай — уже отсортированный массив;
        
    - худший — массив в обратном порядке;
        
    - средний — случайный порядок.
        
    
    То есть “случай” определяет, **какой именно вход** мы подаём алгоритму.
    
2. **Оценка** — это характеристика **функции времени** для данного случая.  
    Символы `O`, `Ω`, `Θ` описывают, как растёт время работы при увеличении `n`,  
    а не какие данные подаются.
    
3. Для каждого случая обычно указывают **только одну оценку**, отражающую его смысл:
    
    - `O(f(n))` — для худшего случая,
        
    - `Θ(f(n))` — для среднего,
        
    - `Ω(f(n))` — для лучшего.
        
    
    Это уже полностью характеризует поведение алгоритма.
    

#### Пример

|Случай|Оценка|Пример для сортировки вставками|
|---|---|---|
|Лучший|`Ω(n)`|Уже отсортированный массив|
|Средний|`Θ(n²)`|Случайные данные|
|Худший|`O(n²)`|Обратный порядок|

Если пытаться дать по три оценки на случай, таблица теряет смысл:  
границы (`O`, `Ω`, `Θ`) уже **включают** идею лучшего, среднего и худшего поведения.

---

### Практические приёмы оценки сложности

1. **Игнорирование констант и младших членов**  
    Например, `3n² + 10n + 5` сводится к `O(n²)`.
    
2. **Вложенные циклы**  
    Если один цикл вложен в другой, время работы — произведение итераций:  
    `n * n → O(n²)`.
    
3. **Последовательные циклы**  
    Если циклы идут последовательно, берётся наибольший порядок:  
    `O(n) + O(n²) = O(n²)`.
    
4. **Анализ рекурсии**  
    Для рекурсивных алгоритмов используется **рекуррентное соотношение**:  
    Например, `T(n) = 2T(n/2) + O(n)` → `O(n log n)`.
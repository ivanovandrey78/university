## 6. Сортировка подсчетом  

**Сортировка подсчётом (Counting Sort)** — это не основанная на сравнении элементов сортировка,  
работающая за **O(n + k)**, где `n` — количество элементов, а `k` — диапазон возможных значений.

### Идея алгоритма

Если известно, что элементы массива — это **целые числа из ограниченного диапазона**,  
можно просто посчитать, сколько раз встречается каждое значение, а затем восстановить массив в отсортированном виде.

_Устойчивость_ сортировки зависит от реализации.
### Пример

Пусть массив:

`[4, 2, 2, 8, 3, 3, 1]`

Подсчёт количества вхождений:

`Значение:     1  2  3  4  5  6  7  8`
`Количество:   1  2  2  1  0  0  0  1`

Восстановление массива по счётчикам:

`[1, 2, 2, 3, 3, 4, 8]`

### Реализация

для чисел в диапазоне 100 (неустойчивая):
```cpp
void count_sort(int* arr, int size) {
    int* count_arr = new int[100]();  // важно инициализировать нулями

    // Подсчёт количества вхождений каждого числа
    for (int i = 0; i < size; i++) {
        count_arr[arr[i] - 1]++;      // -1, т.к. индексация с 0
    }

    int k = 0;

    // Восстановление отсортированного массива
    for (int i = 0; i < 100; i++) {
        while (count_arr[i]-- > 0) {
            arr[k++] = i + 1;         // +1, чтобы вернуть исходное значение
        }
    }

    delete[] count_arr;
}
```

устойчивая реализация через префиксные суммы:
```cpp
void count_sort(int* arr, int n, int max_val) {
    // 1️⃣ Создаём вспомогательные массивы
    int* count = new int[max_val + 1]{0}; // массив частот
    int* output = new int[n];              // результирующий массив (для устойчивости)

    // 2️⃣ Подсчитываем количество вхождений каждого значения
    for (int i = 0; i < n; i++)
        count[arr[i]]++;

    // 3️⃣ Преобразуем count[] в префиксные суммы
    // Теперь count[i] хранит индекс последнего элемента со значением i
    for (int i = 1; i <= max_val; i++)
        count[i] += count[i - 1];

    // 4️⃣ Формируем выходной массив (справа налево — для устойчивости)
    for (int i = n - 1; i >= 0; i--) {
        output[count[arr[i]] - 1] = arr[i];
        count[arr[i]]--;  // уменьшаем индекс для следующего такого же значения
    }

    // 5️⃣ Копируем результат обратно в arr[]
    for (int i = 0; i < n; i++)
        arr[i] = output[i];

    delete[] count;
    delete[] output;
}
```
#### Пояснение работы

1. **Создаётся вспомогательный массив `count_arr`** длиной `k` (здесь 100).  
    В `count_arr[i]` хранится количество элементов, равных `i+1`.
    
2. **Заполняем `count_arr`**:  
    Проходим по всем элементам исходного массива и увеличиваем соответствующий счётчик.
    
3. **Формируем результат**:  
    Проходим по `count_arr`, и для каждого числа, встречающегося `count_arr[i]` раз,  
    записываем это число в итоговый массив.

### Временная сложность

Сортировка подсчётом проходит два этапа:

1. **Подсчёт элементов** — один проход по массиву `O(n)`
2. **Восстановление отсортированного массива** — проход по диапазону значений `O(k)`
    
Таким образом: `O(n + k)`
где
- `n` — число элементов,
- `k` — размер диапазона возможных значений.
    
Если `k` ограничено константой (например, числа от 1 до 100), то алгоритм работает **за линейное время O(n)**.  
Если же диапазон очень велик (`k >> n`), эффективность падает.

### Пространственная сложность

Сортировка использует дополнительный массив счётчиков размером `k`.
Таким образом: `O(k)` 
Counting Sort выгоден **только при сравнительно малом диапазоне значений**.


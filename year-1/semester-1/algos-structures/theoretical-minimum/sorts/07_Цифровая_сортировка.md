## 7. Цифровая сортировка  

### Идея

**Цифровая сортировка (Radix Sort)** — это алгоритм, который сортирует числа **поразрядно**, начиная **с младших разрядов (LSD)** или **со старших (MSD)**.  


Алгоритм не сравнивает элементы напрямую, а обрабатывает их **по цифрам** (или битам, символам и т. д.).

### LSD (Least Significant Digit first)

Сортировка **с наименее значащего разряда**.
На каждом шаге используется **устойчивая сортировка** (обычно **Counting Sort**) по текущему разряду.

**Идея:**

- Сначала сортируем числа по **единицам** (последний разряд),
- потом по **десяткам**, потом по **сотням** и т.д.
- Поскольку используем _устойчивую сортировку_, порядок для одинаковых цифр сохраняется.

#### Пример

Сортируем `[329, 457, 657, 839, 436, 720, 355]`

|Шаг|Разряд|После сортировки|
|---|---|---|
|1|единицы|[720, 355, 436, 457, 657, 839, 329]|
|2|десятки|[720, 329, 436, 839, 355, 457, 657]|
|3|сотни|[329, 355, 436, 457, 657, 720, 839]|

#### Реализация

```cpp
int get_max(int* arr, int size) {
    int mx = arr[0];
    for (int i = 1; i < size; i++)
        if (arr[i] > mx) mx = arr[i];
    return mx;
}

void radix_sort_LSD(int* arr, int size) {
    int max_val = get_max(arr, size);
    for (int exp = 1; max_val / exp > 0; exp *= 10)
        count_sort_digit(arr, size, exp);
}
```

### MSD (Most Significant Digit first)

**Сортировка со старших разрядов.**  
Алгоритм сначала сортирует по самому старшему разряду, а затем **рекурсивно** сортирует каждую подгруппу по следующему разряду.  
Используется для чисел переменной длины или строк.

---

#### Пример

**Исходный массив:**

`[329, 457, 657, 839, 436, 720, 355]`

Сортируем по **разрядам слева направо** (сотни → десятки → единицы).

##### Шаг 1. Сотни (`exp = 100`)

Разбиение по первой цифре:

|Сотни|Элементы|
|---|---|
|3|329, 355|
|4|436, 457|
|6|657|
|7|720|
|8|839|

После этого массив выглядит так:

`[329, 355, 436, 457, 657, 720, 839]`

##### Шаг 2. Рекурсивная сортировка внутри групп

|Группа|Сортировка по десяткам (`exp = 10`)|Результат|
|---|---|---|
|3xx|[329, 355] → [329, 355]|без изменений|
|4xx|[436, 457] → [436, 457]|без изменений|
|6xx+|по одному элементу|без изменений|

---

**Результат:**

`[329, 355, 436, 457, 657, 720, 839]`

---

#### Почему важна устойчивость

Для корректной работы MSD внутри каждой группы элементов, имеющих одинаковый текущий разряд, **необходимо сохранить исходный порядок** — иначе на последующих рекурсивных шагах сортировка нарушится.  
Поэтому _в классической реализации используется устойчивый алгоритм распределения (обычно count sort)_.

Если же внутри подгрупп мы не планируем рекурсивно сортировать (например, при малом числе элементов или фиксированной длине ключа), то устойчивость становится **необязательной** — такие варианты встречаются в практических оптимизациях.

---

#### Реализация 1 — через устойчивый `count sort`

```cpp
void msd_sort_rec(int* arr, int left, int right, int exp) {
    if (left >= right || exp == 0)
        return;

    int count[10] = {0};
    int output[10000];

    // Подсчет цифр
    for (int i = left; i <= right; i++) {
        int digit = (arr[i] / exp) % 10;
        count[digit]++;
    }

    // Префиксные суммы
    for (int i = 1; i < 10; i++)
        count[i] += count[i - 1];

    // УСТОЙЧИВОЕ распределение справа налево
    for (int i = right; i >= left; i--) {
        int digit = (arr[i] / exp) % 10;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }

    // Копируем обратно
    for (int i = 0; i < right - left + 1; i++)
        arr[left + i] = output[i];

    // Рекурсивная сортировка по младшим разрядам
    int start = left;
    for (int d = 0; d < 10; d++) {
        int end = left + count[d] - 1;
        if (start < end)
            msd_sort_rec(arr, start, end, exp / 10);
        start = end + 1;
    }
}

int get_exp(int max_val) {
    int exp = 1;
    while (max_val / exp >= 10)
        exp *= 10;
    return exp;
}

void radix_sort_MSD(int* arr, int size) {
    int max_val = get_max(arr, size);
    int exp = get_exp(max_val);
    msd_sort_rec(arr, 0, size - 1, exp);
}

```

---

#### Реализация 2 — через **бакеты** (естественно устойчивая)

Здесь мы создаём 10 бакетов (по числу цифр), помещаем элементы в них **в порядке появления**, а затем рекурсивно сортируем каждый бакет.

```cpp
void msd_bucket_sort(int* arr, int n, int exp) {
    if (n <= 1 || exp == 0)
        return;

    const int k = 10;                  // Цифры 0–9
    int count[k] = {0};                // Размеры бакетов
    int* buckets[k];                   // Указатели на бакеты
    int max_bucket_size = n;

    // Выделяем память под каждый бакет
    for (int i = 0; i < k; i++)
        buckets[i] = new int[max_bucket_size];

    // Раскладываем элементы по бакетам
    for (int i = 0; i < n; i++) {
        int digit = (arr[i] / exp) % 10;
        buckets[digit][count[digit]++] = arr[i];
    }

    // Рекурсивно сортируем каждый бакет
    for (int i = 0; i < k; i++)
        msd_bucket_sort(buckets[i], count[i], exp / 10);

    // Собираем обратно в исходный массив (в порядке бакетов)
    int idx = 0;
    for (int i = 0; i < k; i++) {
        for (int j = 0; j < count[i]; j++) {
            arr[idx++] = buckets[i][j];
        }
    }

    // Освобождаем память
    for (int i = 0; i < k; i++)
        delete[] buckets[i];
}

int get_exp(int max_val) {
    int exp = 1;
    while (max_val / exp >= 10)
        exp *= 10;
    return exp;
}

void radix_sort_MSD(int* arr, int n) {
    int max_val = *max_element(arr, arr + n);
    int exp = get_exp(max_val);
    msd_bucket_sort(arr, n, exp);
}
```

✅ **Здесь устойчивость сохраняется автоматически**, потому что элементы одинакового разряда добавляются в бакет в исходном порядке (через `push_back`).

---

#### Сравнение LSD и MSD

|Характеристика|**LSD**|**MSD**|
|---|---|---|
|Направление обработки|с младших разрядов|со старших разрядов|
|Реализация|итеративная|рекурсивная|
|Требует устойчивости|обязательно|желательно / обязательно|
|Можно реализовать через|count sort|count sort или бакеты|
|Подходит для|чисел фиксированной длины|чисел/строк переменной длины|
|Типичная область применения|числа|строки, слова|

---

#### Асимптотика

|Показатель|Оценка|
|---|---|
|Время|**O(d · (n + k))**, где `d` — число разрядов, `k` — размер алфавита|
|Память|**O(n + k)**|
|Устойчивость|✅ LSD — да, ✅ MSD — обычно да (при устойчивой внутренней сортировке)|


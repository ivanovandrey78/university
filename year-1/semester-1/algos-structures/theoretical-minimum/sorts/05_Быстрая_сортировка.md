## 5. Быстрая сортировка  

**Быстрая сортировка (Quick Sort)** — это алгоритм сортировки, основанный на принципе **разделяй и властвуй**.  
Она рекурсивно делит массив на две части относительно некоторого **опорного элемента (pivot)**, сортируя их независимо.

Не является устойчивой.

### Основная идея

1. Выбирается **опорный элемент** `pivot`.
2. Все элементы, **меньшие pivot**, перемещаются влево, а **большие — вправо**.
3. Рекурсивно сортируются левая и правая части.
    
После завершения рекурсии массив становится отсортированным.

### Пример

Пусть массив:  
`[5, 2, 9, 1, 7, 3]`

- pivot = 3
- разделяем: `[2, 1] | 3 | [9, 7, 5]`
- рекурсивно сортируем левую и правую части → `[1, 2, 3, 5, 7, 9]`

### Реализация

#### Вариант 1 — Разбиение Ломуто (через последний элемент)

```cpp
void quick_sort(int* arr, int low, int high) {
	if (low >= high) {
		return;    // выход из рекурсии, если массив пустой или длины 1
	}
	int pivot = arr[high];    // опорный элемент, разделяющий arr на 2 части
	int i = low - 1;    // arr[i] - последний элемент arr, который <= pivot
	for (int j = low; j < high; j++) {    // проходим по arr[j], кроме pivot
		if (arr[j] <= pivot) {    // проверяем, в какую часть arr попадет эл-т
			i++;    // расширяем область для эл-тов, меньших pivot
			std::swap(arr[i], arr[j]);    // перемещаем эл-т в область
		}
	}
	std::swap(arr[i+1], arr[high])    // ставим pivot в конце области
	int pivot_index = i + 1;    // запоминаем позицию pivot
	quick_sort(arr, low, pivot_index - 1);    // рекурсия для левой части arr 
	quick_sort(arr, pivot_index + 1, high);    //рекурсия для правой части arr
}
```

**Особенности:**
- Простая реализация.
- Требует больше обменов.
- Плохо работает при множестве одинаковых элементов.

#### Вариант 2 — Ломуто с рандомным pivot

Чтобы избежать **деградации до O(n²)** при неудачном выборе опорного элемента (например, если массив уже отсортирован),  
используется **рандомизация pivot**:

```cpp
#include <cstdlib>

void QuickSort(int* arr, int low, int high) {
	if (low >= high) {
		return;
	}
	rand_index = low + rand() % (high - low + 1);
	std::swap(arr[rand_index], arr[high]);
	int pivot = arr[high];
	int i = low - 1;
	for (int j = low; j < high; j++) {
		if (arr[j] <= pivot) {
			i++;
			std::swap(arr[i], arr[j]);
		}
	std::swap(arr[i + 1], arr[high]);
	int pivot_index = i + 1;
	QuickSort(arr, low, pivot_index - 1);
	QuickSort(arr, pivot_index + 1, high);
	}
}
```

**Преимущество:**  
Рандомизация делает вероятность худшего случая (O(n²)) **практически нулевой** → ожидаемое время **O(n log n)**.
#### Вариант 3 — Разбиение Хоара

```cpp
void QuickSort(int* arr, int low, int high) {
	if (low >= high) {
		return;
	}
	int pivot = arr[(low + high) / 2];
	int i = low - 1;
	int j = high + 1;
	while (true) {
		do {
			i++;
		} while (arr[i] < pivot);
		
		do {
			j--;
		} while (arr[j] > pivot);
	
		if (i >= j) {
			break;
		}
		std::swap(arr[i], arr[j]);
	}
	QuickSort(arr, low, j);
	QuickSort(arr, j + 1, high);
}
```

##### Почему Хоара выгоднее

|Сравнение|Ломуто|Хоара|
|---|---|---|
|**Количество обменов**|Больше — каждый элемент ≤ pivot может меняться местами|Меньше — обмен происходит только при нарушении порядка|
|**Количество сравнений**|Чуть больше|Меньше (≈ на 20–30%)|
|**Эффективность на больших массивах**|Ниже|Выше|
|**Чувствительность к равным элементам**|Сильно замедляется|Работает стабильнее|
|**Диапазон рекурсий**|pivot всегда на своём месте → может быть перекос|Делит массив более сбалансированно|

Как вариант разбиения, можно использовать _три медианы_.

**Итого:**  
Алгоритм Хоара обычно **в 1.3–1.5 раза быстрее**,  
и требует **меньше операций** в среднем.

### Временная сложность

| Случай      | Разделение массива                                      | Время        |
| ----------- | ------------------------------------------------------- | ------------ |
| **Лучший**  | почти равные части                                      | `O(n log n)` |
| **Средний** | случайное распределение                                 | `O(n log n)` |
| **Худший**  | один из подмассивов пустой (уже отсортированный массив) | `O(n²)`      |
### Пространственная сложность

- Рекурсивная глубина стека:
    - **в среднем** — `O(log n)`
    - **в худшем случае** — `O(n)` (если деление сильно неравномерное)


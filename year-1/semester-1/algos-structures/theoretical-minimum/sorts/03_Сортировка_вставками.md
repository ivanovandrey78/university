## 3. Сортировка вставками  

### Идея алгоритма

1. Считаем первый элемент массива **отсортированным**.
    
2. Для каждого следующего элемента ищем правильное место **среди уже отсортированных** элементов слева.
    
3. Сдвигаем элементы, чтобы освободить место, и вставляем текущий элемент.
    
4. Повторяем, пока не пройдём весь массив.
    

> Алгоритм **устойчивый**, так как не меняет порядок равных элементов.

---

### Пример

Исходный массив:  
`[5, 2, 4, 6, 1, 3]`

|Шаг|Текущий элемент|После вставки|
|---|---|---|
|1|2|`[2, 5, 4, 6, 1, 3]`|
|2|4|`[2, 4, 5, 6, 1, 3]`|
|3|6|`[2, 4, 5, 6, 1, 3]` (уже на месте)|
|4|1|`[1, 2, 4, 5, 6, 3]`|
|5|3|`[1, 2, 3, 4, 5, 6]`|

---

### Реализация

```cpp
void InsertionSort(int* arr, int size) {
    for (int i = 1; i < size; i++) {
        int current = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > current) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = current;
    }
}
```

---

### Асимптотическая сложность

|Случай|Описание|Время|
|---|---|---|
|**Лучший (уже отсортирован)**|внутренний цикл не выполняется|**O(n)**|
|**Средний**|элементы смещаются примерно наполовину позиций|**O(n²)**|
|**Худший (обратно отсортирован)**|каждый элемент вставляется в начало, сдвигов ~ `n²/2`|**O(n²)**|

---

### Пространственная сложность

Использует только несколько вспомогательных переменных (`current`, `i`, `j`)  
 **O(1)** — константная память
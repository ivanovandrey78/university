## 4. Сортировка слиянием  

**Сортировка слиянием (Merge Sort)** — алгоритм сортировки, основанный на принципе **«разделяй и властвуй»**.  
Он рекурсивно **делит массив на части**, **сортирует** каждую из них, а затем **сливает** (merge) отсортированные подмассивы в один общий.

> Алгоритм **устойчивый** и имеет одинаковую асимптотику во всех случаях.

---

### Идея сортировки

1. **Разделение:**  
    Разбиваем массив на две половины до тех пор, пока не останется по одному элементу.
    
2. **Рекурсивная сортировка:**  
    Каждая половина рекурсивно сортируется — но **фактическая сортировка происходит при слиянии**, а не при разделении.
    
3. **Слияние:**  
    Две отсортированные половины объединяются в один отсортированный массив.
    

---

### Пример

Массив: `[5, 2, 4, 6, 1, 3]`

Разделение:

`[5, 2, 4, 6, 1, 3] → 
`[5, 2, 4] | [6, 1, 3] → 
`[5, 2] [4] | [6, 1] [3] → 
`[5] [2] [4] [6] [1] [3]`

Слияние:

`[2, 5] [4] | [1, 6] [3] → 
`[2, 4, 5] | [1, 3, 6] → 
`[1, 2, 3, 4, 5, 6]`

---

### Реализация

```cpp
void merge(int arr[], int left, int mid, int right) {
    int size_left = mid - left + 1;    // рамер левого подмассива
    int size_right = right - mid;    // размер правого подмассива
    int* arr_left = new int[size_left];    // создаем временные массивы
    int* arr_right = new int [size_right];
    
    for (int i = 0; i < size_left; i++) {    // копируем в них данные
        arr_left[i] = arr[left + i];
    }
    for (int j = 0; j < size_right; j++) {
        arr_right[j] = arr[mid + 1 + j];
    }
    
    int i = 0, j = 0, k = left;    // сливаем 2 массива в 1
    while (i < size_left && j < size_right) {
        if (arr_left[i] <= arr_right[j]) {
            arr[k] = arr_left[i];
            i++;
        } else {
            arr[k] = arr_right[j];
            j++;
        }
        k++;
    }
    while (i < size_left) {     // добавляем оставшиеся элементы
        arr[k] = arr_left[i];   // (один массив может закончится раньше...
        i++;                    // ... другого)
        k++;
    }
    while (j < size_right) {
        arr[k] = arr_right[j];
        j++;
        k++;
    }
    delete[] arr_left;
    delete[] arr_right;
}

void merge_sort(int arr[], int left, int right) {
    if (left >= right) return;   // выход из рекурсии
    int mid = left + (right - left) / 2;
    merge_sort(arr, left, mid);
    merge_sort(arr, mid + 1, right);
    merge(arr, left, mid, right);
}
```

---

### Временная сложность

- **Разделение:** `log₂(n)` уровней рекурсии.
    
- **Слияние:** на каждом уровне обрабатываются `n` элементов.
    

Итого:  
`T(n) = 2T(n/2) + O(n) → O(n log n)`

|Случай|Оценка времени|Комментарий|
|---|---|---|
|**Лучший**|`O(n log n)`|массив уже отсортирован — всё равно нужно пройти все уровни|
|**Средний**|`O(n log n)`|стандартное поведение|
|**Худший**|`O(n log n)`|независимо от входных данных|

---

### Пространственная сложность

- Временные массивы при слиянии: **O(n)**
    
- Глубина рекурсии: **O(log n)**  
    → Общая: **O(n)** (так как `n >> log n`)
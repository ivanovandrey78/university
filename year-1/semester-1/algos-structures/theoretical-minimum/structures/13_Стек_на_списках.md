## 13. Стек на списках  

### Преимущества реализации на списке

- не нужно заранее задавать размер  
- операции выполняются за **O(1)**  
- не требуется перемещать элементы при вставке или удалении

### Реализация стека на односвязном списке

```cpp
#include <iostream>

struct Node {
    int value;
    Node* next;
    Node(int val) {
        value = val;
        next = nullptr;
    }
};

class Stack {
private:
    Node* top_node;  // вершина стека
    int count;

public:
    Stack() {
        top_node = nullptr;
        count = 0;
    }

    ~Stack() {
        while (top_node) {
            pop();
        }
    }

    void push(int x) {
        Node* node = new Node(x);
        node->next = top_node;
        top_node = node;
        count++;
    }

    void pop() {
        if (!top_node) return;
        Node* temp = top_node;
        top_node = top_node->next;
        delete temp;
        count--;
    }

    int top() {
        if (!top_node) {
            std::cout << "Stack is empty\n";
            return -1;
        }
        return top_node->value;
    }

    bool empty() {
        return top_node == nullptr;
    }

    int size() {
        return count;
    }
};
```


### Асимптотический анализ

|Операция|Время|Память|
|---|---|---|
|`push()`|O(1)|O(1)|
|`pop()`|O(1)|O(1)|
|`top()`|O(1)|O(1)|
|`empty()` / `size()`|O(1)|O(1)|

### Применение

| Область                   | Пример                            |
| ------------------------- | --------------------------------- |
| Рекурсия                  | хранение контекста вызовов        |
| Обратная запись выражений | вычисление постфиксных выражений  |
| Парсинг                   | проверка скобок, разбор выражений |
| Алгоритмы на графах       | DFS (поиск в глубину)             |
| Отмена операций           | undo/redo в текстовых редакторах  |
## **1️⃣ Стек на списках**

### **Идея**

- Каждый узел списка = элемент стека
    
- `head` — вершина стека
    

```
head -> [10|next] -> [20|next] -> [30|next] -> nullptr
```

- `push(x)` → создаём новый узел и делаем его новым `head`
    
- `pop()` → удаляем текущий `head`
    
### **Сложность**

|Операция|Сложность|Память|
|---|---|---|
|push|O(1)|O(1) на узел|
|pop|O(1)|освобождаем узел|
|top|O(1)|—|
## **3️⃣ Плюсы и минусы по сравнению с массивом**

**Плюсы:**

- Не нужна заранее известная длина
    
- Все операции push/pop/enqueue/dequeue O(1)
    
- Нет проблем с амортизацией (как в динамическом массиве)
    

**Минусы:**

- Каждый элемент занимает больше памяти (указатели)
    
- Доступ по индексу O(n) (нельзя быстро взять i-й элемент)
    
- Кэш-память хуже (узлы могут быть разбросаны)
    


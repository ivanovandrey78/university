## 10. Односвязный список  

### Определение

**Односвязный список (Singly Linked List)** — это динамическая структура данных,  
состоящая из узлов (**node**), где каждый узел хранит:

1. **значение (data)**
2. **указатель на следующий элемент (next)**
    

> В отличие от массива, элементы списка не расположены подряд в памяти —  
> каждый элемент знает только о следующем.


### Структура узла

```cpp
struct Node {
    int value;    // значение
    Node* next;   // указатель на следующий элемент
    Node(int val) {
        value = val;
        next = nullptr;
    }
};
```


### Основные операции

|Операция|Описание|Асимптотика по времени|Асимптотика по памяти|
|---|---|---|---|
|`push_front(x)`|вставка в начало|O(1)|O(1)|
|`push_back(x)`|вставка в конец|O(n)|O(1)|
|`pop_front()`|удаление из начала|O(1)|O(1)|
|`pop_back()`|удаление из конца|O(n)|O(1)|
|`insert(pos, x)`|вставка по индексу i|O(i)|O(1)|
|`remove(pos)`|удаление по индексу i|O(i)|O(1)|
|`find(x)`|поиск элемента|O(n)|O(1)|
|`empty()`|проверка на пустоту|O(1)|O(1)|
|`size()`|длина списка|O(n)|O(1)|

### Реализация

```cpp
#include <iostream>

struct Node {
    int value;    // значение
    Node* next;   // указатель на следующий элемент
    Node(int val) {
        value = val;
        next = nullptr;
    }
};

class SinglyLinkedList {
private:
    Node* head;

public:
    SinglyLinkedList() : head(nullptr) {}

    ~SinglyLinkedList() {
        while (head != nullptr) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
    }

    void push_front(int x) {
        Node* node = new Node(x);
        node->next = head;
        head = node;
    }

    void push_back(int x) {
        Node* node = new Node(x);
        if (!head) {
            head = node;
            return;
        }
        Node* cur = head;
        while (cur->next) cur = cur->next;
        cur->next = node;
    }

    void pop_front() {
        if (!head) return;
        Node* temp = head;
        head = head->next;
        delete temp;
    }

    void pop_back() {
        if (!head) return;
        if (!head->next) {
            delete head;
            head = nullptr;
            return;
        }
        Node* cur = head;
        while (cur->next->next) cur = cur->next;
        delete cur->next;
        cur->next = nullptr;
    }

    void print() {
        Node* cur = head;
        while (cur) {
            std::cout << cur->data << " ";
            cur = cur->next;
        }
        std::cout << "\n";
    }
};
```


### Особенности и отличия от массива

|Характеристика|Односвязный список|Массив|
|---|---|---|
|**Выделение памяти**|каждый узел выделяется **в куче (heap)** динамически через `new`|весь массив выделяется **целиком в памяти (stack или heap)** при создании|
|**Индексация**|❌ прямого доступа по индексу нет (нужно проходить последовательно)|✅ доступ по индексу за `O(1)`|
|**Вставка / удаление**|эффективно в начале (`O(1)` при известной ссылке)|дорого: требуется сдвиг элементов (`O(n)`)|
|**Перемещение по элементам**|только вперёд по `next`|двустороннее (через индексы)|
|**Рост структуры**|легко увеличивается — добавляем новые узлы в куче|требует перевыделения памяти (`realloc`) при переполнении|

### Использование

- Реализация **стека**, **очереди**, **хэш-таблиц** (цепочки)
- Работа с **неизвестным числом элементов**
- Когда важны **вставки и удаления**, а не быстрый доступ



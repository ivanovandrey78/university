## 11. Двусвязный список  

### Определение

**Двусвязный список (Doubly Linked List)** — динамическая структура данных,  
в которой каждый элемент (**узел**) хранит:

1. **значение (data)**
    
2. **указатель на предыдущий элемент (prev)**
    
3. **указатель на следующий элемент (next)**
    

> Это расширение односвязного списка, позволяющее двигаться **в обе стороны**.

### Структура узла

```cpp
struct Node {
    int value;
    Node* next;
    Node* prev;
    Node(int val) {
        value = val;
        next = nullptr;
        prev = nullptr;
    }
};
```

### Основные операции

| Операция         | Описание                     | Время| Память|
| ---------------- | ---------------------------- | ---  | O(1)  |
| `push_front(x)`  | добавить в начало            | O(1) | O(1)  |                
| `push_back(x)`   | добавить в конец             | O(1) | O(1)  |                
| `pop_front()`    | удалить из начала            | O(1) | O(1)  |                
| `pop_back()`     | удалить из конца             | O(1) | O(1)  |                 
| `insert(pos, x)` | вставка по индексу i         | O(i) | O(1)  |                 
| `remove(pos)`    | удаление по индексу i        | O(i) | O(1)  |                 
| `find(x)`        | поиск элемента               | O(n) | O(1)  |                 
| `empty()`        | проверка на пустоту          | O(1) | O(1)  |                 
|`size()`          |длина списка                  |O(n)  |O(1)   |

### Реализация двусвязного списка

```cpp
#include <iostream>

struct Node {
    int value;
    Node* next;
    Node* prev;
    Node(int val) {
        value = val;
        next = nullptr;
        prev = nullptr;
    }
};

class DoublyLinkedList {
private:
    Node* head;
    Node* tail;

public:
    DoublyLinkedList() : head(nullptr), tail(nullptr) {}

    ~DoublyLinkedList() {
        while (head) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
    }

    void push_front(int x) {
        Node* node = new Node(x);
        node->next = head;
        if (head) head->prev = node;
        else tail = node; // если список был пуст
        head = node;
    }

    void push_back(int x) {
        Node* node = new Node(x);
        node->prev = tail;
        if (tail) tail->next = node;
        else head = node;
        tail = node;
    }

    void pop_front() {
        if (!head) return;
        Node* temp = head;
        head = head->next;
        if (head) head->prev = nullptr;
        else tail = nullptr;
        delete temp;
    }

    void pop_back() {
        if (!tail) return;
        Node* temp = tail;
        tail = tail->prev;
        if (tail) tail->next = nullptr;
        else head = nullptr;
        delete temp;
    }

    void print_forward() {
        for (Node* cur = head; cur; cur = cur->next)
            std::cout << cur->data << " ";
        std::cout << "\n";
    }

    void print_backward() {
        for (Node* cur = tail; cur; cur = cur->prev)
            std::cout << cur->data << " ";
        std::cout << "\n";
    }
};
```

### Сравнение с односвязным списком

|Свойство|Односвязный|Двусвязный|
|---|---|---|
|Указатели|1 (`next`)|2 (`prev`, `next`)|
|Память на элемент|меньше|больше|
|Движение по списку|только вперёд|вперёд и назад|
|Удаление из конца|O(n)|O(1)|
|Вставка перед элементом|O(n)|O(1) (если есть указатель)|
|Сложность реализации|проще|сложнее|
|Удаление по указателю|O(1)|O(1)|




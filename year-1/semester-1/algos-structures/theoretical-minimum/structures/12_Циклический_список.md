## 12. Циклический список  

### Определение

**Циклический список (Circular Linked List)** — это разновидность связного списка,  
в котором **последний элемент указывает не на `nullptr`, а на первый элемент списка**.

> Таким образом, элементы образуют **замкнутый цикл**.  
> Может быть **односвязным** или **двусвязным**.

### Типы циклических списков

|Вид|Описание|
|---|---|
|**Циклический односвязный**|`next` последнего узла указывает на `head`|
|**Циклический двусвязный**|`next` последнего указывает на `head`, а `prev` первого — на `tail`|
### Преимущества

- Нет "конца" списка — удобно для **круговых структур данных**
    
- Можно **эффективно обходить** все элементы в цикле
    
- Используется в **круговых очередях**, **играх (передача хода)**, **операционных системах (планирование процессов)**
### Основные операции


### Циклический **односвязный** список

|Операция|Описание|Время|Память|
|---|---|---|---|
|`push_front(x)`|вставка в начало|O(1)|O(1)|
|`push_back(x)`|вставка в конец|O(n)|O(1)|
|`pop_front()`|удаление из начала|O(1)|O(1)|
|`pop_back()`|удаление из конца (нужно найти хвост)|O(n)|O(1)|
|`print()`|обход всех элементов (по кругу)|O(n)|O(1)|

_Комментарий:_  
Так как нет обратных ссылок и указателя на `tail`, вставка и удаление с конца требуют прохода по всему списку.

---

### Циклический **двусвязный** список

|Операция|Описание|Время|Память|
|---|---|---|---|
|`push_front(x)`|вставка в начало|O(1)|O(1)|
|`push_back(x)`|вставка в конец|O(1)|O(1)|
|`pop_front()`|удаление из начала|O(1)|O(1)|
|`pop_back()`|удаление из конца|O(1)|O(1)|
|`print()`|обход всех элементов (по кругу)|O(n)|O(1)|

_Комментарий:_  
Благодаря указателю `tail` и полям `prev/next` все операции с концами списка выполняются за O(1).

### Реализация циклического **односвязного** списка

```cpp
#include <iostream>

struct Node {
    int value;
    Node* next;
    Node(int val) {
        value = val;
        next = nullptr;
    }
};

class CircularList {
private:
    Node* tail;  // удобнее хранить указатель на конец списка

public:
    CircularList() : tail(nullptr) {}

    ~CircularList() {
        if (!tail) return;
        Node* cur = tail->next;
        do {
            Node* temp = cur;
            cur = cur->next;
            delete temp;
        } while (cur != tail->next);
        tail = nullptr;
    }

    void push_back(int x) {
        Node* node = new Node(x);
        if (!tail) {
            tail = node;
            tail->next = tail; // единственный элемент указывает на себя
            return;
        }
        node->next = tail->next;
        tail->next = node;
        tail = node;
    }

    void push_front(int x) {
        Node* node = new Node(x);
        if (!tail) {
            tail = node;
            tail->next = tail;
            return;
        }
        node->next = tail->next;
        tail->next = node;
    }

    void pop_front() {
        if (!tail) return;
        Node* head = tail->next;
        if (head == tail) { // единственный элемент
            delete head;
            tail = nullptr;
            return;
        }
        tail->next = head->next;
        delete head;
    }

    void print() {
        if (!tail) return;
        Node* cur = tail->next; // начинаем с головы
        do {
            std::cout << cur->value << " ";
            cur = cur->next;
        } while (cur != tail->next);
        std::cout << "\n";
    }
};
```


### Реализация циклического **двусвязного** списка

```cpp
struct Node {
    int value;
    Node* next;
    Node* prev;
    Node(int val) {
        value = val;
        next = nullptr;
        prev = nullptr;
    }
};

class DoublyCircularList {
private:
    Node* head;

public:
    DoublyCircularList() : head(nullptr) {}

    void push_back(int x) {
        Node* node = new Node(x);
        if (!head) {
            head = node;
            head->next = head;
            head->prev = head;
            return;
        }
        Node* tail = head->prev;
        tail->next = node;
        node->prev = tail;
        node->next = head;
        head->prev = node;
    }

    void print_forward() {
        if (!head) return;
        Node* cur = head;
        do {
            std::cout << cur->value << " ";
            cur = cur->next;
        } while (cur != head);
        std::cout << "\n";
    }
};
```



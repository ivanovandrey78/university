## 14. Очередь на списках  

### Преимущества реализации на списке

- не нужно заранее задавать размер  
- нет переполнения (в отличие от массивов)  
- операции `push` и `pop` выполняются за **O(1)**  
- память выделяется только под реально существующие элементы
### Реализация очереди на односвязном списке
```cpp
#include <iostream>

struct Node {
    int value;
    Node* next;
    Node(int val) {
        value = val;
        next = nullptr;
    }
};

class Queue {
private:
    Node* front_node; // указатель на начало очереди
    Node* rear_node;  // указатель на конец очереди
    int count;

public:
    Queue() {
        front_node = nullptr;
        rear_node = nullptr;
        count = 0;
    }

    ~Queue() {
        while (!empty()) {
            pop();
        }
    }

    void push(int x) {
        Node* node = new Node(x);
        if (!rear_node) {
            front_node = rear_node = node;
        } else {
            rear_node->next = node;
            rear_node = node;
        }
        count++;
    }

    void pop() {
        if (!front_node) return;
        Node* temp = front_node;
        front_node = front_node->next;
        if (!front_node) rear_node = nullptr;
        delete temp;
        count--;
    }

    int front() {
        if (!front_node) {
            std::cout << "Queue is empty\n";
            return -1;
        }
        return front_node->value;
    }

    bool empty() {
        return front_node == nullptr;
    }

    int size() {
        return count;
    }
};
```

### Асимптотический анализ

| Операция             | Время | Память |     |
| -------------------- | ----- | ------ | --- |
| `push()`             | O(1)  | O(1)   |     |
| `pop()`              | O(1)  | O(1)   |     |
| `front()`            | O(1)  | O(1)   |     |
| `empty()` / `size()` | O(1)  | O(1)   |     |
### Применение

| Область                     | Пример                         |
| --------------------------- | ------------------------------ |
| **Обработка событий**       | обработка запросов, сообщений  |
| **Алгоритмы на графах**     | BFS (поиск в ширину)           |
| **Моделирование процессов** | симуляция очередей, клиентов   |
| **Буферизация данных**      | очереди печати, сетевые буферы |
## **2️⃣ Очередь на списках**

### **Идея**

- Каждый узел = элемент очереди
    
- Два указателя: `head` (начало) и `tail` (конец)
    

```
head -> [10|next] -> [20|next] -> [30|next] <- tail
```

- `enqueue(x)` → добавляем новый узел в `tail->next`
    
- `dequeue()` → удаляем `head`
    

### **Сложность**

|Операция|Сложность|Память|
|---|---|---|
|enqueue|O(1)|O(1) на узел|
|dequeue|O(1)|—|
|front|O(1)|—|

---

## **3️⃣ Плюсы и минусы по сравнению с массивом**

**Плюсы:**

- Не нужна заранее известная длина
    
- Все операции push/pop/enqueue/dequeue O(1)
    
- Нет проблем с амортизацией (как в динамическом массиве)
    

**Минусы:**

- Каждый элемент занимает больше памяти (указатели)
    
- Доступ по индексу O(n) (нельзя быстро взять i-й элемент)
    
- Кэш-память хуже (узлы могут быть разбросаны)
    


## 1. Классический бинарный поиск

### Идея

Бинарный поиск применяется для **упорядоченного массива**.  
На каждом шаге сравниваем элемент `a[mid]` с искомым `x` и  
отбрасываем половину массива, где элемента точно нет.

### Пример

Массив `a = [1, 3, 4, 6, 8, 10]`, ищем `x = 6`.

1. `mid = 2`, `a[mid] = 4 < 6` → ищем справа.
    
2. `mid = 4`, `a[mid] = 8 > 6` → ищем слева.
    
3. `mid = 3`, `a[mid] = 6` → найден.
    

### Реализация

```cpp
int binary_search(int a[], int n, int x) {
    int l = 0, r = n - 1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (a[mid] == x) return mid;
        else if (a[mid] < x) l = mid + 1;
        else r = mid - 1;
    }
    return -1; // не найден
}
```

### Сложность

|Операция|Время|Память|
|---|---|---|
|Поиск элемента|`O(log n)`|`O(1)`|

---

## 2. Левосторонний бинарный поиск (lower bound)

### Идея

Найти **первый элемент ≥ x** (наименьший индекс, где значение не меньше x).

### Пример

`a = [1, 3, 3, 5, 8], x = 3`  
Ответ: индекс `1` (первый `3`).

### Реализация

```cpp
int lower_bound(int a[], int n, int x) {
    int l = 0, r = n; // полуинтервал [l, r)
    while (l < r) {
        int mid = (l + r) / 2;
        if (a[mid] < x)
            l = mid + 1;
        else
            r = mid;
    }
    return l; // позиция первого элемента >= x
}
```

## 3. Правосторонний бинарный поиск (upper bound)

### Идея

Найти **первый элемент > x**  
(индекс следующего после всех равных `x`).

### Пример

`a = [1, 3, 3, 5, 8], x = 3`  
Ответ: индекс `3` (элемент `5`).

### Реализация

```cpp
int upper_bound(int a[], int n, int x) {
    int l = 0, r = n;
    while (l < r) {
        int mid = (l + r) / 2;
        if (a[mid] <= x)
            l = mid + 1;
        else
            r = mid;
    }
    return l; // позиция первого элемента > x
}
```

## 4. Бинарный поиск по ответу

### Идея

**Бинарный поиск по ответу** применяется тогда,  
когда мы не можем напрямую "искать элемент",  
но можем проверить, **выполнимо ли условие** при заданном значении параметра.

То есть мы имеем **монотонную булеву функцию** `check(x)`:

`false, false, false, ..., true, true, true`

Алгоритм находит **минимальное значение `x`**,  
для которого `check(x)` впервые становится `true`.

---

### Теоретическая основа

Если некоторая булева функция `check(x)` **монотонна**,  
то есть существует пороговое значение `x*`,  
такое что:

`check(x) = false, если x < x* check(x) = true,  если x ≥ x*`

то бинарный поиск позволяет найти **минимальное x**,  
при котором функция начинает принимать значение `true`.

---

### Пример

Найти минимальное целое `x`, при котором `x² ≥ 30`.

|x|1|2|3|4|5|6|
|---|---|---|---|---|---|---|
|x² ≥ 30?|F|F|F|F|F|T|

Функция `check(x) = (x*x >= 30)`  
впервые становится `true` при `x = 6`.

---

### Реализация

```cpp
bool check(int x) {
    return x * x >= 30;
}

int binary_search_answer(int l, int r) {
    while (l < r) {
        int mid = (l + r) / 2;
        if (check(mid))
            r = mid;     // середина уже подходит — ищем левее
        else
            l = mid + 1; // середина не подходит — ищем правее
    }
    return l; // минимальное x, где check(x) == true
}

```

### Пояснение

- Алгоритм **разделяет** диапазон `[l, r]` на две части:
    
    - слева (`false`-область) условие не выполняется;
        
    - справа (`true`-область) условие выполняется.
        
- В момент, когда `check(mid)` впервые возвращает `true`,  
    порог может быть **в самой середине или правее**,  
    поэтому мы **сдвигаем правую границу**.
    
- По завершении цикла `l == r` — это **точка перехода** функции  
    из `false` в `true`.


### Сложность

| Параметр | Асимптотика     |
| -------- | --------------- |
| Время    | `O(log(range))` |
| Память   | `O(1)`          |

## 5. Вещественный бинарный поиск (поиск корня функции)

### Идея

Используется для нахождения **вещественного корня уравнения**  
или **минимума функции** на отрезке `[L, R]`.

Работает на основе **теоремы Больцано–Коши**:

> Если функция `f(x)` непрерывна на `[a, b]`  
> и `f(a) * f(b) < 0`,  
> то существует `c ∈ (a, b)`, где `f(c) = 0`.

---

### Пример

Найти корень `f(x) = x³ - x - 2 = 0`  
на отрезке `[1, 2]`.

- `f(1) = -2`, `f(2) = 4` → знаки разные → корень существует.
    

---

### Реализация

```cpp
#include <iostream>
#include <cmath>

double f(double x) {
    return x * x * x - x - 2;
}

double find_root(double L, double R, double eps = 1e-6) {
    if (f(L) * f(R) > 0) {
        std::cerr << "Нет гарантии корня на данном интервале!" << std::endl;
        return NAN;
    }

    while (R - L > eps) {
        double mid = (L + R) / 2;
        if (f(L) * f(mid) <= 0)
            R = mid;
        else
            L = mid;
    }
    return (L + R) / 2;
}

```


### Сложность

|Этап|Сложность|
|---|---|
|До точности ε|`O(log((R - L)/ε))`|
|Память|`O(1)`|


## 6. Тернарный поиск (ternary search)

### Идея

Используется для поиска **экстремума (минимума или максимума)**  
монотонной  функции.

Принцип:  
разделяем интервал `[L, R]` на **три части**,  
и выбрасываем ту, где экстремум точно отсутствует.

---

### Пример

Функция `f(x)` сначала убывает, потом возрастает —  
нужно найти минимум.

### Реализация
```cpp
double ternary_search(double L, double R, double eps = 1e-6) {
    while (R - L > eps) {
        double m1 = L + (R - L) / 3;
        double m2 = R - (R - L) / 3;
        if (f(m1) < f(m2))
            R = m2;
        else
            L = m1;
    }
    return (L + R) / 2; // точка минимума
}
```

### Сложность

|Этап|Сложность|
|---|---|
|До точности ε|`O(log((R - L)/ε))`|
|Память|`O(1)`|

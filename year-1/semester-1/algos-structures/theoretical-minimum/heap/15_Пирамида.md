## 15. Пирамида (построение пирамиды, восстановление свойств пирамиды)  

### Определение

**Пирамида (куча, heap)** — абстрактная структура данных, являющаяся полным бинарным деревом, обладающим свойством кучи:

- **Для max-heap**: каждый родитель ≥ своих потомков
    
- **Для min-heap**: каждый родитель ≤ своих потомков
    

#### Дерево
Дерево — это иерархическая структура данных, в которой каждый элемент (называемый узлом)
может иметь ноль или больше потомков (дочерних узлов).

- Самый верхний элемент называется корень (root).
- Узлы без потомков называются листьями (leaves).
- Каждый узел (кроме корня) имеет ровно одного родителя (parent).

```
        A          ← корень
       / \
      B   C        ← потомки A
     / \   \
    D   E   F      ← листья

```
#### Бинарное дерево

Бинарное дерево — это частный случай дерева,
в котором у каждого узла не более двух потомков:

- левый ребёнок (left child)
- правый ребёнок (right child)

```
        8
       / \
      3   10
     / \    \
    1   6    14

```
#### Полное дерево

Важно различать *полное бинарное дерево* и *совершенное бинарное дерево*.

*Полное бинарное дерево* (complete binary tree)
- Все уровни, кроме последнего, полностью заполнены.
- Последний уровень заполнен слева направо.

```
        1
       / \
      2   3
     / \  /
    4  5 6
```

*Совершенное бинарное дерево* (perfect binary tree)
- Все уровни полностью заполнены.
- У всех узлов (кроме листьев) по 2 ребенка.

```
        1
       / \
      2   3
     / \ / \
    4  5 6  7
```

### Хранение пирамиды

Пирамиду часто хранят **в виде массива**, а не в виде указателей на узлы.  
Это позволяет просто вычислять индексы потомков:

```cpp
left(i) = 2 * i + 1;
right(i) = 2 * i + 2;
parent(i) = (i - 1) / 2;
```

### Пример max-heap

```
          10
        /    \
      7        5
     / \      / \
    2   1    3   4

```

Массивное представление:  
`[10, 7, 5, 2, 1, 3, 4]`


### Основные операции

|Операция|Описание|Сложность|
|---|---|---|
|**heapify_down(i)**|восстановление свойства кучи вниз|O(log n)|
|**heapify_up(i)**|восстановление свойства кучи вверх|O(log n)|
|**build_heap()**|построение кучи из массива|O(n)|
|**insert(x)**|добавление нового элемента|O(log n)|
|**extract_max()**|извлечение максимального (min для min-heap)|O(log n)|

### Восстановление свойств пирамиды

#### **1. Просеивание вниз (heapify_down)**

Используется, если нарушено свойство кучи в корне или у родителя.

**Идея:** сравнить элемент с детьми и, если он меньше (для max-heap), поменять местами с наибольшим из них.

```cpp
void heapify_down(int* arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;

    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        heapify_down(arr, n, largest);
    }
}
```

### **2. Просеивание вверх (heapify_up)**

Используется после вставки нового элемента в конец.

**Идея:** сравниваем элемент с родителем и поднимаем вверх, пока не восстановится свойство кучи.

```cpp
void heapify_up(int* arr, int i) {
    while (i > 0 && arr[(i - 1) / 2] < arr[i]) {
        std::swap(arr[i], arr[(i - 1) / 2]);
        i = (i - 1) / 2;
    }
}
```

### Применение 


| Область                              | Где используется                            | Что делает куча                                                          |
| ------------------------------------ | ------------------------------------------- | ------------------------------------------------------------------------ |
| **Сортировка**                       | **Heap Sort**                               | Реализация сортировки с `O(n log n)` временем и `O(1)` памятью           |
| **Структуры данных**                 | **Очередь с приоритетами (priority queue)** | Позволяет быстро доставать минимальный/максимальный элемент (`O(log n)`) |
| **Графовые алгоритмы**               | **Дейкстра, Прим, A***                      | Оптимизация выбора следующей вершины с минимальной стоимостью            |
| **Планировщики задач**               | **ОС, системы очередей, event loop**        | Хранение задач по приоритету или времени исполнения                      |
| **Алгоритмы k-наибольших элементов** | Поиск top-k значений                        | Поддерживает k-элементов с логарифмической вставкой                      |
| **Потоковые данные**                 | **Median of stream**, Sliding window        | Быстрое обновление и извлечение минимума/максимума                       |
|  **Huffman coding**                  | Построение дерева Хаффмана                  | Выбор двух минимальных весов на каждом шаге                              |

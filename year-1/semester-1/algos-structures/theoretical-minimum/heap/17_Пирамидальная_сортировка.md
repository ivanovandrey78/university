## 17. Пирамидальная сортировка  

### Суть алгоритма

**Пирамидальная сортировка (Heap Sort)** — это алгоритм сортировки, основанный на структуре **бинарной кучи (heap)**.  
Куча позволяет эффективно получать и удалять **максимальный (или минимальный)** элемент за `O(log n)`.

Идея алгоритма:

1. Построить **макс-кучу** из массива (`O(n)`).
    
2. Повторять:
    
    - Поменять местами корень (максимум) с последним элементом.
        
    - Уменьшить размер кучи на 1.
        
    - Восстановить свойство кучи (`heapify_down`) за `O(log n)`.
        

После `n` итераций массив становится отсортированным по возрастанию.

### Принцип работы

Пусть массив — это полное бинарное дерево:

- Индекс родителя: `parent = (i - 1) / 2`
    
- Индексы потомков: `left = 2 * i + 1`, `right = 2 * i + 2`
    

**Построение кучи:**

- Начинаем с середины массива (`n / 2 - 1`) и выполняем `heapify_down` для каждого узла.
    
- После этого корень — максимальный элемент.
    

**Сортировка:**

- Меняем `arr[0]` и `arr[n - 1]`.
    
- Уменьшаем «размер кучи».
    
- Просеиваем вниз новый корень (`heapify_down`).

### Реализация

```cpp
void heapify(int* arr, int n, int i) {
    int largest = i;       // индекс наибольшего элемента
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest])
        largest = left;
    if (right < n && arr[right] > arr[largest])
        largest = right;

    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        heapify(arr, n, largest); // рекурсивно восстанавливаем кучу
    }
}

void heap_sort(int* arr, int n) {
    // 1. Построение max-heap
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // 2. Извлечение элементов из кучи
    for (int i = n - 1; i > 0; i--) {
        std::swap(arr[0], arr[i]);   // максимум в конец
        heapify(arr, i, 0);          // восстановить свойство кучи
    }
}
```

### Свойства

| Свойство         | Описание                                                          |
| ---------------- | ----------------------------------------------------------------- |
| **Сложность**    | `O(n log n)` во всех случаях                                      |
| **Память**       | Работает _in-place_, не требует дополнительного массива           |
| **Устойчивость** | Неустойчива (элементы с равными ключами могут поменяться местами) |

## 16. Построение пирамиды O(n)  

### Построение пирамиды (build_heap)

Чтобы из неупорядоченного массива построить кучу, выполняется **просеивание вниз (heapify_down)**, начиная с последнего родителя:

```cpp
void heapify_down(int* arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;

    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        heapify_down(arr, n, largest);
    }
}

void build_heap(int* arr, int n) {
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify_down(arr, n, i);
    }
}
```


### Почему сложность O(n), а не O(n log n)

На первый взгляд кажется, что раз `heapify_down` — O(log n), а вызывается он для `n/2` элементов,  
то должно быть `O(n log n)`.  
Но это **ошибочно**, потому что не каждый узел просеивается на всю глубину.

### Математический вывод: почему построение пирамиды — **O(n)**

### Структура дерева

Пирамида — это **полное бинарное дерево**.  
Высота дерева:
```
h = ⌊log₂ n⌋
```

Уровни считаем **от низа вверх**:

- уровень `0` — листья,
    
- уровень `1` — родители листьев,
    
- …
    
- уровень `h` — корень.

### Сколько узлов на уровне `k`

На нижнем уровне (`k = 0`) примерно половина всех узлов — это листья.  
Чем выше уровень, тем меньше узлов —  
каждый уровень содержит вдвое меньше узлов, чем предыдущий.

Примерно:

```
число узлов на уровне k ≈ n / 2^(k + 1)
```

### Сколько работы делает каждый узел

Операция `heapify_down(i)` (просеивание вниз)  
может затронуть максимум `k` уровней, если узел находится на уровне `k` (от низа).

Поэтому стоимость одной операции на уровне `k`: `≈ O(k)`

### Суммируем вклад всех уровней

Общая трудоёмкость:

`T(n) = сумма (число узлов на уровне) × (стоимость heapify_down)`

`T(n) = ∑_{k=0}^{h} (n / 2^(k + 1)) × O(k)`

### Вынесем константы

n не зависит от k, вынесем её за знак суммы:

`T(n) = O(n) × ∑_{k=0}^{h} (k / 2^(k + 1))`

`∑_{k=0}^{∞} (k / 2^k) = 2`

`T(n) = O(n) × O(1) = O(n)`
